---
title: "Tipps & Tricks for data analysis in R"
author: "Nils Eling"
date: "`r Sys.Date()`"
output: 
    html_document:
        toc: true
        toc_float: true
        theme: sandstone
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

This script serves a teaching material for the workshop "Tipps & Tricks for 
data analysis in R" presented at the DQBM retreat 2022.

It slightly builds upon the [Introduction to Data Analysis](https://uzh.sharepoint.com/:f:/r/sites/DQBMIntranet524/Shared%20Documents/General/All%20things%20computational/2020%20Introduction%20to%20Data%20Analysis/R?csf=1&web=1&e=hjXCdd) sessions
that were held in March 2020.

Some of the concepts are taken from [Advanced R](https://adv-r.hadley.nz/index.html),
an excellent book to dive deeper into how R works.

The session will address very different aspects of data analysis and programming
using the statistical programming language R. To follow the session, please install [R](https://stat.ethz.ch/CRAN/) and [RStudio](https://www.rstudio.com/products/rstudio/download/#download) and install the following packages in R:

```{r, eval=FALSE}
install.packages("BiocManager")
BiocManager::install("R6", "BiocParallel", "DT", "vroom", "data.table", "bench", "forcats", "stringr", "dplyr", "purrr", "readr", "tidyr", "tibble", "ggplot2", "tidyverse")
```

To follow the session live, please clone the repository locally

```
git clone https://github.com/BodenmillerGroup/IntroDataAnalysis.git
cd IntroDataAnalysis/R/DQBM_retreat_2022
```

and open the file `tipps_tricks.Rmd`.

## Coding style and flow

In the first section, we will discuss very basic coding practices in R mainly
focusing on the assignment operator, pipes and function calls. For a full
overview on coding stlye recommendations please refer to [the tidyverse style guide](https://style.tidyverse.org/index.html).

### Assignment operator

The assignment operator `<-` and `->` in R is the preferred way of assigning
variables. It alows left sided and right sided assignment while `=` is always
interpreted as `<-` outside function calls. The `=` is reserved for parameter
setting within function calls.

Calling `<-` within a function call allows assignment of a previously undefined
variable.

```{r, error=TRUE}
y = 1:10
y
1:10 = y

z <- 1:10
z
1:10 -> z
z

mean(x = 1:10)
x

mean(x <- 1:10)
x

# Incorrect assignment within function call
system.time(x = lapply(1:10, function(x) {Sys.sleep(1); return(x)}))

# Assignment to x within function call
system.time(x <- lapply(1:10, function(x) {Sys.sleep(1); return(x)}))
```

### Pipes

Using pipes in R improves readability of you code. In the next code chunk we 
want to find the date at which the maximum of accumulated Covid-19
cases were detected in Switzerland.

For this, base R by now provides the pipe operator `|>`.

```{r}
covid <- read.csv("../../Data/covid19.csv")

str(covid)

# Bad
covid[covid$Country.Region == "Switzerland" & covid$Confirmed == max(covid[covid$Country.Region == "Switzerland", "Confirmed"]),"Date"]

# Good
covid |> 
    subset(Country.Region == "Switzerland") |> 
    subset(Confirmed == max(Confirmed)) |> 
    getElement("Date")
```

The [tidyverse](https://www.tidyverse.org/) package provides all base packages
for [tidy
data](https://cran.r-project.org/web/packages/tidyr/vignettes/tidy-data.html)
handling in R. 
The pipe operator `%>%` is provided by the `magrittr` package.

```{r, message=FALSE}
library(tidyverse)

covid %>%
    filter(Country.Region == "Switzerland") %>%
    filter(Confirmed == max(Confirmed)) %>%
    select("Date")
```

Even though this is not recommended, piping naturally fits to right
sided assignments:

```{r}
# Bad but fun
covid %>%
    filter(Country.Region == "Switzerland") %>%
    filter(Confirmed == max(Confirmed)) %>%
    select("Date") -> max_conf_date
max_conf_date

# Good
max_conf_date <- covid %>%
    filter(Country.Region == "Switzerland") %>%
    filter(Confirmed == max(Confirmed)) %>%
    select("Date")
max_conf_date
```

One of the key features of piping is the direct use with `ggplot2` for
plotting.

```{r, fig.width=12}
covid %>%
    filter(Country.Region == "Switzerland") %>%
    ggplot() + geom_line(aes(Date, Confirmed, color = Country.Region, group = 1)) +
    theme_classic(base_size = 15) +
    theme(axis.text.x = element_text(angle = 90))
```

## Efficient coding

The next section focuses on how to perform computations efficiently in (base) R.
One of the best packages for efficient computations in [data.table](https://cran.r-project.org/web/packages/data.table/vignettes/datatable-intro.html)
but we won't have enough time to go through it.

### Reading in data

Reading in large datasets in R can be a pain and the base R fiunctions are
not optimized for this.

To test a number of file reader functions, we will first generate a "large" dataset
on the fly and write it to disk:

```{r, eval=FALSE}
matrix(rnorm(n = 10000000), ncol = 10) %>%
    as.data.frame() %>%
    write_csv(file = "../../Data/large_test_data.csv")
```

The resulting `.csv` file contains 1 million rows and 10 columns and has 
a size of 200mb on disk.

In the next code chunk we will test the following file reader functions:

* `read.csv`: base R function for reading in `.csv` files
* `readr::read_csv`: standard tidy R function
* `data.table::fread`: main reader function of the `data.table` package
* `vroom::vroom`: newer library playing along with tidy R

We will now use the [bench](https://bench.r-lib.org/) library to perform some
benchmarks on which reader function is the best.

```{r, message=FALSE, warning=FALSE}
library(bench)
library(data.table)
library(vroom)
library(DT)

bench::mark(
    cur_data <- read.csv("../../Data/large_test_data.csv"),
    cur_data <- readr::read_csv("../../Data/large_test_data.csv"),
    cur_data <- data.table::fread("../../Data/large_test_data.csv"),
    cur_data <- vroom::vroom("../../Data/large_test_data.csv"),
    check = FALSE
) %>% select(c("min", "median", "mem_alloc", "total_time")) %>%
    DT::datatable()
```

We can see that the base R reader function has by far the worst performance.
The `readr::read_csv` function has already a decent performance and should be
used whenever possible - especially when you plan on using the `tidyverse` 
packages, which you should ;). 

The `vroom::vroom` function in this case does not seem to be much faster than 
the other ones bu memory allocation is drastically reduced. You should be
using this one when reading in gigabytes and gigabytes of data.

### Loops and apply

The R programming language performs best when using [vectorized operations](https://bookdown.org/rdpeng/rprogdatascience/vectorized-operations.html).
Only in certain cases it is needed to use a `for` loop to iterated over objects.

The following code chunk highlights the worst possible way of calculating
the average value per row of a matrix:

```{r}
cur_data <- as.matrix(cur_data[1:100000,])

out <- vector()

# Bad
for (i in 1:nrow(cur_data)) {
    cur_mean <- mean(cur_data[i,])
    out <- c(out, cur_mean)
}

head(out, 100)
```

Here, we used a `for` loop to iterate through all rows. In addition, 
we overwrite the full vector `out` in each iteration.

If you want/need to use a `for` loop it is better to first create the output
object and only replace individual entries:

```{r}
out <- vector(mode = "numeric", length = nrow(cur_data))

# Slightly better if needed
for (i in 1:nrow(cur_data)) {
    cur_mean <- mean(cur_data[i,])
    out[i] <- cur_mean
}
```

In any case, it is recommended to use functions of the `apply` family to perform
iterated operations. To oerate on arrays and matrices, base R provides the 
`apply` function:

```{r}
# Much better
out <- apply(cur_data, MARGIN = 1, FUN = mean)
head(out, 100)
```

Here, `MARGIN` can be `1` to iterate over rows, `2` to iterate over columns
or even `3` or higher to iterate over higher dimensions when working with
`arrays`. 

For most easy operations, base R provides easy vecorized functions, such as
`rowMeans`:

```{r}
# Best
out <- rowMeans(cur_data)
head(out, 100)
```

In the next sections we will go through the different functions of the `apply`
family:

* `apply`: as seen above used on matrix-like objects
* `lapply`: used on lists/vectors, returns a list
* `sapply`: used on lists/vectors, returns a vector
* `vapply`: used on lists/vectors, returns a vector with checking
* `tapply`: applies a function per grouping level
* `mapply`: combines multiple lists

In the following example we will generate a list which contains 10 entries,
each of which is a numeric vector of length 10 which can contain NAs.

We will then compute the mean per entry while ignoring NAs. Finally, we will
convert the list to a vector in different ways.

```{r}
cur_list <- lapply(1:10, function(x){
    c(rnorm(n = 10), rep(NA, 10))[sample(1:20, 10)]
})

out <- lapply(cur_list, mean, na.rm = TRUE)
out

do.call(c, out)
as.numeric(out)
as(out, "numeric")
```

In the next example, we can see that most operators in R are also defined as
functions. Here, we can first access the 3rd element of each entry of a list and
even perform assignments to individual entries. Here we see again that it's 
important to understand what the assignment operator is. All replacement
functions in R are defined using the assignment operator. 

```{r, error=TRUE}
x <- list(entr1 = 1:10, entr2 = 20:30)

lapply(x, `[[`, 3)

lapply(x, `[[<-`, 3, 120)

lapply(x, `[[=`, 3, 120)
```

The next function we will look at is `sapply` which operates similarly as
`lapply` but returnes a "simplified" version of the output (e.g. directly a vector).

```{r}
sapply(cur_list, mean, na.rm = TRUE)
```

However, it is not always trivial to simplify the output since it's not always
clear what the output is. When developing computational methods it's always
safer to use `vapply` which checks the type and length out the output.

```{r, error=TRUE}
# A single numeric should be returned
vapply(cur_list, mean, FUN.VALUE = 0, na.rm = TRUE)

# Two objects are returned
vapply(cur_list, 
       function(x){return(c("one", "two"))}, 
       FUN.VALUE = c("test1", "test2"))

# Doesn't work
vapply(cur_list, mean, FUN.VALUE = "test")
```

The `tapply` function performs operations on groups of an input.
In the following case, we will calculate the maximum of confirmed covid cases
per country. 

Similar operations can be done with the base R `aggregate` function and
with tidy R.

```{r}
# tapply
head(tapply(covid$Confirmed, covid$Country.Region, max), 10)

# aggregate
head(aggregate(covid$Confirmed, by = list(country = covid$Country.Region), max), 10)

# tidy R
covid %>%
    group_by(Country.Region) %>%
    summarize(max_confirmed = max(Confirmed)) %>%
    head(10)
```
Finally, the `mapply` combines a number of lists and performs operations on each 
paired entry:

```{r}
cur_list_2 <- as.list(1:10)
mapply(function(x, y){
    return(mean(x, na.rm = TRUE) * y)
},
cur_list, cur_list_2)

mapply(`*`, cur_list_2, cur_list_2)
```

### Parallelisation

One strength of R is to be able to perform operations in a parallelized fashion.
For this a number of packages have been developed including [parallel](https://stat.ethz.ch/R-manual/R-devel/library/parallel/doc/parallel.pdf),
[foreach](https://cran.r-project.org/web/packages/foreach/vignettes/foreach.html) and [future](https://future.futureverse.org/). 

Personally, I prefer the
[BiocParallel](https://bioconductor.org/packages/release/bioc/html/BiocParallel.html)
package as it provides a user-friendly way of handling parallelised operations
by simply extending the `lapply` function.

In the next code chunk, we will test how the `bplapply` function works. 
The only additional parameter is `BPPARAM` which in the following case is set
to `bpparam()`. The `bbparam()` function registers a parallelisation
backend which is most suited to your operating system.

```{r}
library(BiocParallel)

bench::mark(
    cur_out <- lapply(1:10, function(x){Sys.sleep(5); return(x)}),
    cur_out <- bplapply(1:10, function(x){Sys.sleep(5); return(x)}, BPPARAM = bpparam()),
    memory = FALSE
) %>% select(c("min", "median", "mem_alloc", "total_time")) %>%
    DT::datatable()
```

## Object-oriented programming

In the next section we will learn how obbject oriented programming (OOP) can
be done in R. Even without knowing what that means you have used OOP whenever
you code in R.

OOP in R consists of the following three parts:

* **object**: they store data in a pre-defined form
* **generic function**: functions that perform a certain task
* **methods**: apply a generic function on a certain object

Understanding OOP in R is mainly relevant for methods development but
also useful to understand where differences in the way you analyse data come from.

We will first start with observing the difference between a `base type` and a 
`class attribute`. Every object in R has a base type while only OOP onjects
have a `class attribute`.

```{r}
attr(1:10, "class")
typeof(1:10)
# mIsleading
class(1:10)
is(1:10, "integer")

attr(matrix(1:10), "class")
typeof(matrix(1:10))
class(matrix(1:10))
is(matrix(1:10), "integer")

# Class inheritance
is(matrix(1:10), "matrix")
is(matrix(1:10), "array")
```

We will now directly move to defining OOP objects, generic functions and
methods in different ways. Please refer to [Object Oriented Programming](https://adv-r.hadley.nz/oo.html)
for full information.

Most objects that you work with when analyzing data in base R are of the "S3" class.
This is a loosely defined construct for which generic functions and methods exist
and allow the user and developer lots of flexibility.

The [Bioconductor]() project mainly works with "S4" classes which are a lot
more formally defined and allow for easier interoperability.

The "R6" class provides a framework which comes closest to real OOP as known 
from e.g. python.

In the following sections, we will go through different examples and how to 
construct objects, generic functions and methods.

### S3 class

S3 class objects are most often used in base R functions. For example,
the `prcomp` function to compute a PCA returns an object of class `prcomp`.
Each slot of a S3 class object can be accessed via `$`.

```{r}
cur_pca <- prcomp(iris[,-5])

class(cur_pca)

# Access slots via "$"
head(cur_pca$sdev)
```

Also base objects such as a `factor` or a `data.frame` are S3 objects which can
be tested. In base R there are generic functions defined which can be applied to
an S3 object. Here an example of such a generic function is `print`. Internally,
`print` will find the matching method to be called on the provided object.

```{r}
f <- factor(c("a", "b", "c"))
df <- data.frame(a = 1:10, b = letters[1:10])
is.object(f)
is.object(df)

# generic functions - always use these
isS3stdGeneric("print")
print(f)
print(df)

# methods - never use these
isS3method("print.factor")
print.factor(f)
print.factor(df)

print.data.frame(df)
print.data.frame(f)
```

There is never the need to directly call a method on an object but rather use
the generic function.

In the next few chunks we will learn how to build an object of a certain class,
how to construct a generic function and how to construct a method.

We will first construct an S3 class object.

```{r, error=TRUE}
# Create, then set class
x <- 1
class(x) <- "my_class"

class(x)
inherits(x, "my_class")
inherits(x, "your_class")
```

Next, we can define a generic function:

```{r}
my_generic <- function(x) UseMethod("my_generic", x)
```

Finally, we will link a method to the object class and the generic function.

```{r, error=TRUE}
my_generic.my_class <- function(x) x + 10

my_generic(x)
my_generic(20)
```

### S4 class

The S4 class system is more formally defined, One would first need to 
define the structure of the class. In the following example, we will first define
a class "Person" which contains slots to store the name and the character of the
person.

We can then use the `new` function to create a new object of class "Person".
Slots in the object can be accessed via `@` or the `slot` function.

```{r}
setClass("Person", 
  slots = c(
    name = "character", 
    age = "numeric"
  )
)

john <- new("Person", name = "John Smith", age = as.numeric(NA))

is(john)
isS4(john)

# Access slots via "@"
john@name

slot(john, "age")
```

Next, we can define a new generic function calle `age` for getting the age 
of a person and `age<-` for setting the age of a person.

```{r}
setGeneric("age", function(x) standardGeneric("age"))
setGeneric("age<-", function(x, value) standardGeneric("age<-"))
```

Finally, we can construct the methods linked to the `age` and `age<-` generic
functions and the `Person` object:

```{r}
setMethod("age", "Person", function(x) x@age)
setMethod("age<-", "Person", function(x, value) {
  x@age <- value
  x
})

age(john) <- 50
age(john)
```

### R6 class

Just for demonstration purposes, we will also discuss the R6 class.
Here, within the class definition one can directly specify class
methods without the need to constructing generic functions.

```{r, error=TRUE}
library(R6)

# Class definition
Person <- R6Class("Person", list(
  name = NULL,
  age = NA,
  # Validity checks on the class construction
  initialize = function(name, age = NA) {
    stopifnot(is.character(name), length(name) == 1)
    stopifnot(is.numeric(age), length(age) == 1)
    
    self$name <- name
    self$age <- age
  },
  # Print method
  print = function(...) {
    cat("Person: \n")
    cat("  Name: ", self$name, "\n", sep = "")
    cat("  Age:  ", self$age, "\n", sep = "")
    invisible(self)
  },
  # Another method
  add_years = function(x) {
    self$age <- self$age + x 
    invisible(self)
  }
))

nils <- Person$new("Nils", age = "thirty-three")
nils <- Person$new("Nils", age = 33)

nils$print()
# In place operation
nils$add_years(10)
nils$print()
nils$age

nils$
    add_years(10)$
    age
```

## Common pitfalls

In the last chapter, I wanted to highlight a few common pitfalls when analysing
data in R.

### Vector recycling

For some reason, vector recycling is possible in R. Issues commonly arise
when using a logical vector for subsetting. In the following example a vector
of length 3 is recycled when subsetting a much larger data.frame without throwing 
an error. Please make sure that the logical vector always has the same length
of the object that you want to subset.

```{r}
dim(iris)

cur_vector <- c(TRUE, FALSE, TRUE)
dim(iris[cur_vector,])

cur_vector <- iris$Species == "virginica"
dim(iris[cur_vector,])
```

It is important to understand that the `.drop` or `drop` argument exists in R.
When using tidy R most often missing combinations of factor levels are
dropped by default:

```{r}
iris$subspecies <- factor(rep(letters[1:5], each = 30))

iris %>% count(Species, subspecies) 

iris %>% count(Species, subspecies, .drop = FALSE)
```

When writing functions, make sure to always explicitely return an object
with `return`. Otherwise the output of the last call within the function will
be returned.

```{r}
out <- lapply(1:10, function(x){
    cur_out <- data.frame(index = rep(x, 10))
    cur_out$table <- cur_out$index * 1:10
})
out

out <- lapply(1:10, function(x){
    cur_out <- data.frame(index = rep(x, 10))
    cur_out$table <- cur_out$index * 1:10
    return(cur_out)
})
out
```

## Session info

Here are the packages used in this workshop.

```{r, sessionInfo}
sessionInfo()
```