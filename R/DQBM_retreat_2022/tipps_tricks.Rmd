---
title: "Tipps & Tricks for data analysis in R"
author: "Nils Eling"
date: "`r Sys.Date()`"
output: 
    html_document:
        toc: true
        toc_float: true
        theme: sandstone
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

This script serves a teaching material for the workshop "Tipps & Tricks for 
data analysis in R" presented at the DQBM retreat 2022.

It slightly builds upon the [Introduction to Data Analysis](https://uzh.sharepoint.com/:f:/r/sites/DQBMIntranet524/Shared%20Documents/General/All%20things%20computational/2020%20Introduction%20to%20Data%20Analysis/R?csf=1&web=1&e=hjXCdd) sessions
that were held in March 2020.

Some of the concepts are taken from [Advanced R](https://adv-r.hadley.nz/index.html),
an excellent book to dive deeper into how R works.

The session will address very different aspects of data analysis and programming
using the statistical programming language R. To follow the session, please install [R](https://stat.ethz.ch/CRAN/) and [RStudio](https://www.rstudio.com/products/rstudio/download/#download) and install the following packages in R:

```{r, eval=FALSE}
install.packages("BiocManager")
BiocManager::install("R6", "BiocParallel", "DT", "vroom", "data.table", "bench", "forcats", "stringr", "dplyr", "purrr", "readr", "tidyr", "tibble", "ggplot2", "tidyverse")
```

## Coding style and flow

In the first section, we will discuss very basic coding practices in R mainly
focusing on the assignment operator, pipes and function calls. For a full
overview on coding stlye recommendations please refer to [the tidyverse style guide](https://style.tidyverse.org/index.html).

### Assignment operator

The assignment operator `<-` and `->` in R is the preferred way of assigning
variables. It alows left sided and right sided assignment while `=` is always
interpreted as `<-` outside function calls. The `=` is reserved for parameter
setting within function calls.

Calling `<-` within a function call allows assignment of a previously undefined
variable.

```{r, error=TRUE}
y = 1:10
y
1:10 = y

z <- 1:10
z
1:10 -> z
z

mean(x = 1:10)
x

mean(x <- 1:10)
x

# Incorrect assignment within function call
system.time(x = lapply(1:10, function(x) {Sys.sleep(1); return(x)}))

# Assignment to x within function call
system.time(x <- lapply(1:10, function(x) {Sys.sleep(1); return(x)}))
```

### Pipes

Using pipes in R improves readability of you code. In the next code chunk we 
want to find the date at which the maximum of accumulated Covid-19
cases were detected in Switzerland.

For this, base R by now provides the pipe operator `|>`.

```{r}
covid <- read.csv("../../Data/covid19.csv")

str(covid)

# Bad
covid[covid$Country.Region == "Switzerland" & covid$Confirmed == max(covid[covid$Country.Region == "Switzerland", "Confirmed"]),"Date"]

# Good
covid |> 
    subset(Country.Region == "Switzerland") |> 
    subset(Confirmed == max(Confirmed)) |> 
    getElement("Date")
```

The [tidyverse](https://www.tidyverse.org/) package provides all base packages
for [tidy
data](https://cran.r-project.org/web/packages/tidyr/vignettes/tidy-data.html)
handling in R. 
The pipe operator `%>%` is provided by the `magrittr` package.

```{r, message=FALSE}
library(tidyverse)

covid %>%
    filter(Country.Region == "Switzerland") %>%
    filter(Confirmed == max(Confirmed)) %>%
    select("Date")
```

Even though this is not recommended, piping naturally fits to right
sided assignments:

```{r}
# Bad but fun
covid %>%
    filter(Country.Region == "Switzerland") %>%
    filter(Confirmed == max(Confirmed)) %>%
    select("Date") -> max_conf_date
max_conf_date

# Good
max_conf_date <- covid %>%
    filter(Country.Region == "Switzerland") %>%
    filter(Confirmed == max(Confirmed)) %>%
    select("Date")
max_conf_date
```

One of the key features of piping is the direct use with `ggplot2` for
plotting.

```{r, fig.width=12}
covid %>%
    filter(Country.Region == "Switzerland") %>%
    ggplot() + geom_line(aes(Date, Confirmed, color = Country.Region, group = 1)) +
    theme_classic(base_size = 15) +
    theme(axis.text.x = element_text(angle = 90))
```

## Efficient coding

The next section focuses on how to perform computations efficiently in (base) R.
One of the best packages for efficient computations in [data.table](https://cran.r-project.org/web/packages/data.table/vignettes/datatable-intro.html)
but we won't have enough time to go through it.

### Reading in data

Reading in large datasets in R can be a pain and the base R fiunctions are
not optimized for this.

To test a number of file reader functions, we will first generate a "large" dataset
on the fly and write it to disk:

```{r, eval=FALSE}
matrix(rnorm(n = 10000000), ncol = 10) %>%
    as.data.frame() %>%
    write_csv(file = "../../Data/large_test_data.csv")
```

The resulting `.csv` file contains 1 million rows and 10 columns and has 
a size of 200mb on disk.

In the next code chunk we will test the following file reader functions:

* `read.csv`: base R function for reading in `.csv` files
* `readr::read_csv`: standard tidy R function
* `data.table::fread`: main reader function of the `data.table` package
* `vroom::vroom`: newer library playing along with tidy R

We will now use the [bench](https://bench.r-lib.org/) library to perform some
benchmarks on which reader function is the best.

```{r, message=FALSE, warning=FALSE}
library(bench)
library(data.table)
library(vroom)
library(DT)

bench::mark(
    cur_data <- read.csv("../../Data/large_test_data.csv"),
    cur_data <- readr::read_csv("../../Data/large_test_data.csv"),
    cur_data <- data.table::fread("../../Data/large_test_data.csv"),
    cur_data <- vroom::vroom("../../Data/large_test_data.csv"),
    check = FALSE
) %>% select(c("min", "median", "mem_alloc", "total_time")) %>%
    DT::datatable()
```

We can see that the base R reader function has by far the worst performance.
The `readr::read_csv` function has already a decent performance and should be
used whenever possible - especially when you plan on using the `tidyverse` 
packages, which you should ;). 

The `vroom::vroom` function in this case does not seem to be much faster than 
the other ones bu memory allocation is drastically reduced. You should be
using this one when reading in gigabytes and gigabytes of data.

### Loops and apply

The R programming language performs best when using [vectorized operations](https://bookdown.org/rdpeng/rprogdatascience/vectorized-operations.html).
Only in certain cases it is needed to use a `for` loop to iterated over objects.

The following code chunk highlights the worst possible way of calculating
the average value per row of a matrix:

```{r}
cur_data <- as.matrix(cur_data[1:100000,])

out <- vector()

# Bad
for (i in 1:nrow(cur_data)) {
    cur_mean <- mean(cur_data[i,])
    out <- c(out, cur_mean)
}

head(out, 100)
```

Here, we used a `for` loop to iterate through all rows. In addition, 
we overwrite the full vector `out` in each iteration.

If you want/need to use a `for` loop it is better to first create the output
object and only replace individual entries:

```{r}
out <- vector(mode = "numeric", length = nrow(cur_data))

# Slightly better if needed
for (i in 1:nrow(cur_data)) {
    cur_mean <- mean(cur_data[i,])
    out[i] <- cur_mean
}
```

In any case, it is recommended to use functions of the `apply` family to perform
iterated operations. To oerate on arrays and matrices, base R provides the 
`apply` function:

```{r}
# Much better
out <- apply(cur_data, MARGIN = 1, FUN = mean)
head(out, 100)
```

Here, `MARGIN` can be `1` to iterate over rows, `2` to iterate over columns
or even `3` or higher to iterate over higher dimensions when working with
`arrays`. 

For most easy operations, base R provides easy vecorized functions, such as
`rowMeans`:

```{r}
# Best
out <- rowMeans(cur_data)
head(out, 100)
```

In the next sections we will go through the different functions of the `apply`
family:

* `apply`: as seen above used on matrix-like objects
* `lapply`: used on lists/vectors, returns a list
* `sapply`: used on lists/vectors, returns a vector
* `vapply`: used on lists/vectors, returns a vector with checking
* `tapply`: applies a function per grouping level
* `mapply`: combines multiple lists

In the following example we will generate a list which contains 10 entries,
each of which is a numeric vector of length 10 which can contain NAs.

We will then compute the mean per entry while ignoring NAs. Finally, we will
convert the list to a vector in different ways.

```{r}
cur_list <- lapply(1:10, function(x){
    c(rnorm(n = 10), rep(NA, 10))[sample(1:20, 10)]
})

out <- lapply(cur_list, mean, na.rm = TRUE)
out

do.call(c, out)
as.numeric(out)
as(out, "numeric")
```

In the next example, we can see that most operators in R are also defined as
functions. Here, we can first access the 3rd element of each entry of a list and
even perform assignments to individual entries. Here we see again that it's 
important to understand what the assignment operator is. All replacement
functions in R are defined using the assignment operator. 

```{r, error=TRUE}
x <- list(entr1 = 1:10, entr2 = 20:30)

lapply(x, `[[`, 3)

lapply(x, `[[<-`, 3, 120)

lapply(x, `[[=`, 3, 120)
```

The next function we will look at is `sapply` which operates similarly as
`lapply` but returnes a "simplified" version of the output (e.g. directly a vector).

```{r}
sapply(cur_list, mean)
```

However, it is not always trivial to simplify the output since it's not always
clear what the output is. When developing computational methods it's always
safer to use `vapply` which checks the type and length out the output.

```{r, error=TRUE}
# A single numeric should be returned
vapply(cur_list, mean, FUN.VALUE = 0)

# Two objects are returned
vapply(cur_list, 
       function(x){return(c("one", "two"))}, 
       FUN.VALUE = c("test1", "test2"))

# Doesn't work
vapply(cur_list, mean, FUN.VALUE = "test")
```

The `tapply` function performs operations on groups of an input.
In the following case, we will calculate the maximum of confirmed covid cases
per country. 

Similar operations can be done with the base R `aggregate` function and
with tidy R.

```{r}
# tapply
head(tapply(covid$Confirmed, covid$Country.Region, max), 10)

# aggregate
aggregate(covid$Confirmed, by = list(country = covid$Country.Region), max)

# tidy R
covid %>%
    group_by(Country.Region) %>%
    summarize(max_confirmed = max(Confirmed))
```
Finally, the `mapply` combines a number of lists and performs operations on each 
paired enrty:

```{r}
cur_list_2 <- as.list(1:10)
mapply(function(x, y){
    return(mean(x) * y)
},
cur_list, cur_list_2)

mapply(`*`, cur_list_2, cur_list_2)
```

### Parallelisation

One strength of R is to be able to perform operations in a parallelized fashion.
For this a number of packages have been developed including [parallel](https://stat.ethz.ch/R-manual/R-devel/library/parallel/doc/parallel.pdf),
[foreach](https://cran.r-project.org/web/packages/foreach/vignettes/foreach.html) and [future](https://future.futureverse.org/). 

Personally, I prefer the
[BiocParallel](https://bioconductor.org/packages/release/bioc/html/BiocParallel.html)
package as it provides a user-friendly way of handling parallelised operations
by simply extending the `lapply` function.

In the next code chunk, we will test how the `bplapply` function works. 
The only additional parameter is `BPPARAM` which in the following case is set
to `bpparam()`. The `bbparam()` function registers a parallelisation
backend which is most suited to your operating system.

```{r}
library(BiocParallel)

bench::mark(
    cur_out <- lapply(1:10, function(x){Sys.sleep(5); return(x)}),
    cur_out <- bplapply(1:10, function(x){Sys.sleep(5); return(x)}, BPPARAM = bpparam()),
    memory = FALSE
)
```

## Object-oriented coding

Mainly relevant for development and not analysis but good to understand

```{r}
attr(1:10, "class")
typeof(1:10)
class(1:10)
is(1:10, "integer")

attr(matrix(1:10), "class")
typeof(matrix(1:10))
class(matrix(1:10))
is(matrix(1:10), "integer")

# Class inheritance
is(matrix(1:10), "matrix")
is(matrix(1:10), "array")
```

### S3 class

```{r}
cur_pca <- prcomp(iris[,-5])

class(cur_pca)

print(cur_pca)
plot(cur_pca)

# Access slots via "$"
head(cur_pca$sdev)
```

```{r}
f <- factor(c("a", "b", "c"))
df <- data.frame(a = 1:10, b = letters[1:10])

# generic functions - always use these
print(f)
print(df)

# methods - never use these
print.factor(f)
print.factor(df)

print.data.frame(df)
print.data.frame(f)
```

```{r, error=TRUE}
# Create, then set class
x <- 1
class(x) <- "my_class"

class(x)
inherits(x, "my_class")
inherits(x, "your_class")

# build a generic function
```

S3 generic

```{r}
my_generic <- function(x) UseMethod("my_generic", x)
```

S3 method

```{r, error=TRUE}
my_generic.my_class <- function(x) x + 10

my_generic(x)
my_generic(20)
```

### S3 class

```{r}
setClass("Person", 
  slots = c(
    name = "character", 
    age = "numeric"
  )
)

john <- new("Person", name = "John Smith", age = as.numeric(NA))

is(john)

# Access slots via "@"
john@name

slot(john, "age")
```

S4 generic

```{r}
setGeneric("age", function(x) standardGeneric("age"))
setGeneric("age<-", function(x, value) standardGeneric("age<-"))
```

S4 method

```{r}
setMethod("age", "Person", function(x) x@age)
setMethod("age<-", "Person", function(x, value) {
  x@age <- value
  x
})

age(john) <- 50
age(john)
```

### R6 class

```{r, error=TRUE}
library(R6)

Person <- R6Class("Person", list(
  name = NULL,
  age = NA,
  initialize = function(name, age = NA) {
    stopifnot(is.character(name), length(name) == 1)
    stopifnot(is.numeric(age), length(age) == 1)
    
    self$name <- name
    self$age <- age
  },
  print = function(...) {
    cat("Person: \n")
    cat("  Name: ", self$name, "\n", sep = "")
    cat("  Age:  ", self$age, "\n", sep = "")
    invisible(self)
  },
  add_years = function(x) {
    self$age <- self$age + x 
    invisible(self)
  }
))

nils <- Person$new("Nils", age = "thirty-three")
nils <- Person$new("Nils", age = 33)

nils$print()
nils$add_years(10)
nils$print()
nils$age

nils$
    add_years(10)$
    age
```

## Common pitfalls

Vector recycling

```{r}
dim(iris)

cur_vector <- c(TRUE, FALSE, TRUE)
dim(iris[cur_vector,])

cur_vector <- iris$Species == "virginica"
dim(iris[cur_vector,])
```

the `drop` argument

```{r}
iris$subspecies <- factor(rep(letters[1:5], each = 30))

iris %>% count(Species, subspecies) 

iris %>% count(Species, subspecies, .drop = FALSE)
```

use `return`

```{r}
out <- lapply(1:10, function(x){
    cur_out <- data.frame(index = rep(x, 10))
    cur_out$table <- cur_out$index * 1:10
})
out

out <- lapply(1:10, function(x){
    cur_out <- data.frame(index = rep(x, 10))
    cur_out$table <- cur_out$index * 1:10
    return(cur_out)
})
out
```

## Session info

Here are the packages used in this workshop.

```{r, sessionInfo}
sessionInfo()
```