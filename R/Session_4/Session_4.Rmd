---
title: "Session 3: tidyverse and publication-ready figures"
author: "Nils"
date: "`r Sys.Date()`"
output: html_notebook
---

In this session, I will give an introduction to `Bioconductor` and how to perform single-cell analysis using `Bioconductor` packages.
This session introduces the concept of "object-oriented" programming - or at least how to understand it in R.
We will use the `SingleCellExperiment` class object as an example - however the skills learned in this session can be easily applied to other high-dimensional data analysis tasks.
The `SingleCellExperiment` class is a so called `S4` class object and the prefered object type in Bioconductor.
Check out [https://adv-r.hadley.nz/oo.html](https://adv-r.hadley.nz/oo.html) for in depth explanations on opbject-oriented programming in R.

Why do we want to use the `SingleCellExperiment` object?

* It allows consistent sub-setting of cells and markers without breaking the connection between expression counts and metadata
* It allows efficient on-disk storing in form of `.rds` files
* Everything is in one place
* By now, more than 70 packages provide functions to alter the `SingleCellExperiment` object - you don't need to implement functions yourself

## Bioconductor

Bioconductor provides tools for the analysis and comprehension of high-throughput genomic data. Bioconductor uses the R statistical programming language, and is open source and open development. It has two releases each year, and an active user community.

Check out the [https://bioconductor.org/](https://bioconductor.org/) website.

Bioconductor version 3.10 offers 1823 [software packages](https://bioconductor.org/packages/release/BiocViews.html#___Software), 957 [Annotation packages](https://www.bioconductor.org/packages/release/BiocViews.html#___AnnotationData), 385 [ExperimentData packages](https://www.bioconductor.org/packages/release/BiocViews.html#___ExperimentData) and 27 [Workflows](https://www.bioconductor.org/packages/release/BiocViews.html#___Workflow).

Bioconductor packages can be conveniently installed using `BiocManager`:

```{r BiocManager}
install.packages("BiocManager")
BiocManager::install("SingleCellExperiment")

# Should be '3.10'
BiocManager::version()

# Should be true
BiocManager::valid()
```

I prefer using the `BiocManager::install` since it checks if there are outdated packages - important to include bug fixes.
The `BiocManager::install` function also allows you to install CRAN and Github packages.

```{r BiocManager-2}
BiocManager::install("igraph")
BiocManager::install("JinmiaoChenLab/Rphenograph")
```

Bioconductor packages are released twice a year - once in April/May, once in October.
Unless you are developing Bioconductor packages, you won't need to use Bioconductor devel.
But here are more information: [Bioc devel](https://www.bioconductor.org/developers/how-to/useDevel/)

## The `SingleCellExperiment` class

Here, I will use the `SingleCellExperiment` class object as an example for object-oriented data analysis in R.
Other widely used objects are [SummarizedExperiment](https://www.bioconductor.org/packages/release/bioc/html/SummarizedExperiment.html) containers, from which the `SingleCellExperiment` class inherits. 

To work with the object, I will mostly follow the [Orchestrating Single-Cell Analysis with Bioconductor](https://osca.bioconductor.org/) workflow, an excellent resource to do single-cell data analysis in R using Bioconductor.

**Of note:** The workflow was written for single-cell RNA sequencing data and some concepts (e.g. normalization) do not apply to CyTOF data analysis.

Here, we will start with the [data analysis infrastructure](https://osca.bioconductor.org/data-infrastructure.html) section of the OSCA workflow.

### Read in data

We will first read in the data that we want to analyse.
For convenience, I stored the raw expression counts (mean pixel intensity per cell) in one .csv file, the marker-specific metadata in one .csv file and the cell-specific metadata in one .csv file.

```{r read-in-data}
# Read in counts
pancreas_counts <- read.csv("~/Github/IntroDataAnalysis/Data/pancreas_counts.csv", 
                            stringsAsFactors = FALSE, row.names = 1)
head(pancreas_counts)
dim(pancreas_counts)

# Read in cell metadata
cell_meta <- read.csv("~/Github/IntroDataAnalysis/Data/pancreas_cellmeta.csv", 
                      stringsAsFactors = FALSE, row.names = 1)
head(cell_meta)

# Read in marker metadata
marker_meta <- read.csv("~/Github/IntroDataAnalysis/Data/pancreas_markermeta.csv", 
                      stringsAsFactors = FALSE, row.names = 1)
head(marker_meta)
```

In most cases, it is safe to compare the order of rows and columns:

```{r check-ordering}
identical(rownames(pancreas_counts), rownames(cell_meta))
identical(colnames(pancreas_counts), rownames(marker_meta))

# Check why the colnames and rownames don't match
colnames(pancreas_counts)
rownames(marker_meta)

# Fix colnames
colnames(pancreas_counts) <- gsub("\\.", "-", colnames(pancreas_counts))
identical(colnames(pancreas_counts), rownames(marker_meta))
```

In general, it is recommended not to use spaces or special characters when labelling markers or cells.

### Build `SingleCellExperiment` object

As you can imagine, it would be a bit annoying to handle three different objects side-by-side.
That's why we can store everything in one single container: the `SingleCellExperiment` object.

```{r SingleCellExperiment}
library(SingleCellExperiment)

sce <- SingleCellExperiment(assays = list(counts = t(pancreas_counts)), colData = cell_meta)
sce

colnames(sce)
rownames(sce)

dim(sce)
ncol(sce)
nrow(sce)
```

The `SingleCellExperiment` stores cells in the columns and markers in rows.

We can now also store the cell- and marker-specific metadata in the SCE object.
These need to be `DataFrame` objects - a Bioconductor-specific class similar to `tibble`, `data.table` and `data.frame`.

```{r SingleCellExperiment-2}
library(S4Vectors)
colData(sce) <- DataFrame(cell_meta)
rowData(sce) <- DataFrame(marker_meta)

sce
```

We have now successfully created a `SingleCellExperiment`!

### Add other assays

We have now stored the raw counts in the SCE object.

```{r assay-1}
assays(sce)
assayNames(sce)
dim(counts(sce))
```

For dimensionality reduction and clustering, it is often preferred to work with distributions that are normal-like.
We can now also store transformed and scaled counts in the same object:

```{r transformation}
assay(sce, "exprs") <- asinh(counts(sce) / 1)
assay(sce, "scaled") <- t( scale( t( assay(sce, "exprs") ) ) )

rowMeans(assay(sce, "scaled"))
rowVars(assay(sce, "scaled"))
```

## Dimensionality reduction

In this section, we will learn how to perform common dimensionality reduction methods using the `scater` package.
We will start by peforming a principal component analysis.
For this, we can use the `runPCA` function provided by the scater package.



## Visualization


## Clustering

knn

Rphenograph

flowSOM
