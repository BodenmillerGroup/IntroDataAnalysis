---
title: "Tipps & Tricks for data analysis in R"
author: "Nils Eling"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Concepts taken from [Advanced R](https://adv-r.hadley.nz/index.html).

## Assignment operator and pipes

```{r, error=TRUE}
y = 1:10
y

z <- 1:10
z

mean(x = 1:10)
x

mean(x <- 1:10)
x

system.time(x = lapply(1:10, function(x) {Sys.sleep(1); return(x)}))

system.time(x <- lapply(1:10, function(x) {Sys.sleep(1); return(x)}))
```

```{r}
covid <- read.csv("../../Data/covid19.csv")

str(covid)

covid[covid$Country.Region == "Switzerland" & covid$Confirmed == max(covid[covid$Country.Region == "Switzerland", "Confirmed"]),"Date"]

covid |> 
    subset(Country.Region == "Switzerland") |> 
    subset(Confirmed == max(Confirmed)) |> 
    getElement("Date")
```

Same with tidyverse.

```{r}
library(tidyverse)

covid %>%
    filter(Country.Region == "Switzerland") %>%
    filter(Confirmed == max(Confirmed)) %>%
    select("Date")
```

Pipe into variable 

```{r}
covid %>%
    filter(Country.Region == "Switzerland") %>%
    filter(Confirmed == max(Confirmed)) %>%
    select("Date") -> max_conf_date
max_conf_date
```

```{r, fig.width=12}
covid %>%
    filter(Country.Region == "Switzerland") %>%
    ggplot() + geom_line(aes(Date, Confirmed, color = Country.Region, group = 1)) +
    theme_classic(base_size = 15) +
    theme(axis.text.x = element_text(angle = 90))
```

## Efficient coding

### Reading in data

Write large data frame

```{r, eval=FALSE}
matrix(rnorm(n = 10000000), ncol = 10) %>%
    as.data.frame() %>%
    write_csv(file = "../../Data/large_test_data.csv")
```

`read.csv` vs `read_cvs` vs `data.table` vs `vroom`

```{r, message=FALSE}
library(bench)
library(data.table)
library(vroom)
library(DT)

bench::mark(
    cur_data <- read.csv("../../Data/large_test_data.csv"),
    cur_data <- readr::read_csv("../../Data/large_test_data.csv"),
    cur_data <- data.table::fread("../../Data/large_test_data.csv"),
    cur_data <- vroom::vroom("../../Data/large_test_data.csv"),
    check = FALSE
) %>% DT::datatable()
```

### Loops and apply

Bad

```{r}
cur_data <- as.matrix(cur_data[1:100000,])

out <- vector()

for (i in 1:nrow(cur_data)) {
    cur_mean <- mean(cur_data[i,])
    out <- c(out, cur_mean)
}

head(out, 100)
```

Better

```{r}
out <- apply(cur_data, MARGIN = 1, FUN = mean)
head(out, 100)
```

Best 

```{r}
out <- rowMeans(cur_data)
head(out, 100)
```

Different apply functions:

* apply
* lapply
* sapply
* vapply
* tapply
* mapply

```{r}
cur_list <- lapply(1:10, function(x){
    rnorm(n = sample(1:10, 1))
})

out <- lapply(cur_list, mean)
out

do.call(c, out)
```

```{r}
x <- list(entr1 = 1:10, entr2 = 20:30)

lapply(x, `[[`, 3)

lapply(x, `[[<-`, 3, 120)
```

```{r}
sapply(cur_list, mean)
```

```{r, error=TRUE}
vapply(cur_list, mean, FUN.VALUE = 0)

vapply(cur_list, mean, FUN.VALUE = "test")
```

```{r}
tapply(covid$Confirmed, covid$Country.Region, max)

aggregate(covid$Confirmed, by = list(country = covid$Country.Region), max)

covid %>%
    group_by(Country.Region) %>%
    summarize(max_confirmed = max(Confirmed))
```

```{r}
cur_list_2 <- as.list(1:10)
mapply(function(x, y){
    return(mean(x) * y)
},
cur_list, cur_list_2)

mapply(`*`, cur_list_2, cur_list_2)
```

### Parallelisation

BiocParallel

lot's of packages: [parallel], [foreach], [future]

I recommend [BiocParallel]

```{r}
library(BiocParallel)

bench::mark(
    cur_out <- lapply(1:10, function(x){Sys.sleep(5); return(x)}),
    cur_out <- bplapply(1:10, function(x){Sys.sleep(5); return(x)}, BPPARAM = bpparam()),
    memory = FALSE
)
```

## Object-oriented coding

Mainly relevant for development and not analysis but good to understand

```{r}
attr(1:10, "class")
typeof(1:10)
class(1:10)
is(1:10, "integer")

attr(matrix(1:10), "class")
typeof(matrix(1:10))
class(matrix(1:10))
is(matrix(1:10), "integer")

# Class inheritance
is(matrix(1:10), "matrix")
is(matrix(1:10), "array")
```

```{r}
cur_pca <- prcomp(iris[,-5])

class(cur_pca)

print(cur_pca)
plot(cur_pca)

# Access slots via "$"
head(cur_pca$sdev)
```

```{r}
f <- factor(c("a", "b", "c"))
df <- data.frame(a = 1:10, b = letters[1:10])

# generic functions - always use these
print(f)
print(df)

# methods - never use these
print.factor(f)
print.factor(df)

print.data.frame(df)
print.data.frame(f)
```

S3 class

```{r, error=TRUE}
# Create, then set class
x <- 1
class(x) <- "my_class"

class(x)
inherits(x, "my_class")
inherits(x, "your_class")

# build a generic function
```

S3 generic

```{r}
my_generic <- function(x) UseMethod("my_generic", x)
```

S3 method

```{r, error=TRUE}
my_generic.my_class <- function(x) x + 10

my_generic(x)
my_generic(20)
```

S4 class

```{r}
setClass("Person", 
  slots = c(
    name = "character", 
    age = "numeric"
  )
)

john <- new("Person", name = "John Smith", age = as.numeric(NA))

is(john)

# Access slots via "@"
john@name

slot(john, "age")
```

S4 generic

```{r}
setGeneric("age", function(x) standardGeneric("age"))
setGeneric("age<-", function(x, value) standardGeneric("age<-"))
```

S4 method

```{r}
setMethod("age", "Person", function(x) x@age)
setMethod("age<-", "Person", function(x, value) {
  x@age <- value
  x
})

age(john) <- 50
age(john)
```

R6 

```{r, error=TRUE}
library(R6)

Person <- R6Class("Person", list(
  name = NULL,
  age = NA,
  initialize = function(name, age = NA) {
    stopifnot(is.character(name), length(name) == 1)
    stopifnot(is.numeric(age), length(age) == 1)
    
    self$name <- name
    self$age <- age
  },
  print = function(...) {
    cat("Person: \n")
    cat("  Name: ", self$name, "\n", sep = "")
    cat("  Age:  ", self$age, "\n", sep = "")
    invisible(self)
  },
  add_years = function(x) {
    self$age <- self$age + x 
    invisible(self)
  }
))

nils <- Person$new("Nils", age = "thirty-three")
nils <- Person$new("Nils", age = 33)

nils$print()
nils$add_years(10)
nils$print()
nils$age

nils$
    add_years(10)$
    age
```

## Common pitfalls

Vector recycling

```{r}
dim(iris)

cur_vector <- c(TRUE, FALSE, TRUE)
dim(iris[cur_vector,])

cur_vector <- iris$Species == "virginica"
dim(iris[cur_vector,])
```

the `drop` argument

```{r}
iris$subspecies <- factor(rep(letters[1:5], each = 30))

iris %>% count(Species, subspecies) 

iris %>% count(Species, subspecies, .drop = FALSE)
```

use `return`

```{r}
out <- lapply(1:10, function(x){
    cur_out <- data.frame(index = rep(x, 10))
    cur_out$table <- cur_out$index * 1:10
})
out

out <- lapply(1:10, function(x){
    cur_out <- data.frame(index = rep(x, 10))
    cur_out$table <- cur_out$index * 1:10
    return(cur_out)
})
out
```


## Session info

Here are the packages used in this workshop.

```{r, sessionInfo}
sessionInfo()
```